---
draft: false
original: content/zh/post/1893-检查是否区域内所有整数都被覆盖.md
title: 1893-Check if all integers in the region are covered
description: null
categories:
- leetcode
date: 2021-07-23 00:00:00
summary: null
---

# 1893. Check if all integers in the region are covered

**Release Date:** July 23, 2021

####1893. Check if all integers in the region are covered

I didn't think of any good way to get it, so I used brute force to solve it first.```javascript
var isCovered = function(ranges, left, right) {
    for(let i = left ; i <= right ; i ++) {
        let include = false        for(let index = 0 ; index < ranges.length ; index ++) {
            let [start,end] = ranges[index]
            if (i >=start && i <=end) {
                include = true            }
        }
        if (!include) return false    }
    return true};
```Thinking about optimization, you can use start, end. When start <= left, the [left ... end] set is already included. Continue compressing [end + 1, right] until there are no elements in the set.```javascript
var isCovered = function(ranges, left, right) {
    ranges = ranges.sort((a,b) => a - b)
    for(let i = 0 ; i < ranges.length;i++) {
        let [start,end] = ranges[i];        // Shrink the left boundary according to the range if (start <= left) {
            left = Math.max(end,right)
        }
        if (left >= right) {
            return true        }
    }
    return left >= right
};
```<!-- ORIGINAL CHINESE BODY STARTS -->
# 1893. Check if all integers in the range are covered

**Release Date:** July 23, 2021

####1893. Check if all integers in the region are covered

I didn't think of any good way to get it, so I used brute force to solve it first.```javascript
var isCovered = function(ranges, left, right) {
    for(let i = left ; i <= right ; i ++) {
        let include = false        for(let index = 0 ; index < ranges.length ; index ++) {
            let [start,end] = ranges[index]
            if (i >=start && i <=end) {
                include = true            }
        }
        if (!include) return false    }
    return true};
```Thinking about optimization, you can use start, end. When start <= left, the [left ... end] set is already included. Continue compressing [end + 1, right] until there are no elements in the set.```javascript
var isCovered = function(ranges, left, right) {
    ranges = ranges.sort((a,b) => a - b)
    for(let i = 0 ; i < ranges.length;i++) {
        let [start,end] = ranges[i];        // Shrink the left boundary according to the range if (start <= left) {
            left = Math.max(end,right)
        }
        if (left >= right) {
            return true        }
    }
    return left >= right
};
```<!-- ORIGINAL CHINESE BODY ENDS -->
