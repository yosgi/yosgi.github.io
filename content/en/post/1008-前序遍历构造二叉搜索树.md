---
draft: true
original: 'content/zh/post/1008-前序遍历构造二叉搜索树.md'
title: 1008-前序遍历构造二叉搜索树
description: 
categories:
  - leetcode
date: 2021-03-10 00:00:00
summary: 
---

# ENGLISH TRANSLATION NEEDED

This is an automatically generated English stub. Please translate the content below into English and remove the `draft: true` flag when ready.

<!-- ORIGINAL CHINESE CONTENT STARTS -->
# 1008. 前序遍历构造二叉搜索树

**发布日期：** 2021年03月10日

用时 ： 没做出来

没做出来的主要原因是一直想着怎么用栈来做，写到后面看栈的答案看着看着发现递归最简单

### 递归

思路很简单，首先写出来怎么插入子节点

1. 如果比父节点小，且父节点左为空，直接做左节点
1. 如果比父节点大，且父节点右为空，直接做右节点
1. 比父节点小，则父节点赋值为父节点的左节点，回到 1
1. 比父节点大，则父节点赋值为父节点的右节点，回到1
遍历整个数组，一个个插入即可得到结果

```javascript
var bstFromPreorder = function(preorder) {
    var add = function (node,val) {
        if (val < node.val && !node.left) {
            node.left = new TreeNode(val)
        }
        if (val > node.val && !node.right) {
            node.right = new TreeNode(val)
        }
        if (val < node.val) {
            add(node.left,val)
        }
        if (val > node.val) {
            add(node.right,val)
        }
    }
    var root = new TreeNode(preorder.shift())
    for(let i = 0 ; i < preorder.length ; i ++) {
        add(root,preorder[i])
    }
    return root};
```
<!-- ORIGINAL CHINESE CONTENT ENDS -->
