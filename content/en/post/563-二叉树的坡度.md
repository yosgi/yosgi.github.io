---
draft: true
original: 'content/zh/post/563-二叉树的坡度.md'
title: 563-二叉树的坡度
description: 
categories:
  - leetcode
date: 2021-03-16 00:00:00
summary: 
---

# ENGLISH TRANSLATION NEEDED

This is an automatically generated English stub. Please translate the content below into English and remove the `draft: true` flag when ready.

<!-- ORIGINAL CHINESE CONTENT STARTS -->
# 563. 二叉树的坡度

**发布日期：** 2021年03月16日

用时：15min

用时：15min

拿到题的第一反应是是用递归，然后直接开始写了后发现

递归需要满足的条件是问题可以拆分成子问题，但是根据题意，我们需要求的是每个节点左右节点和的差值，这个 “左右节点和” 对于每个节点来说，都是不一样的问题

所以还是双递归

```javascript
var findTilt = function(root) {
    var total = 0    var innerDFS = function (root) {
        if (!root) return 0        var left = 0 ,right = 0        if (root.left) {
            left = innerDFS(root.left)
        }
        if (root.right) {
            right = innerDFS(root.right)
        }
        return root.val + left + right
    }
    var outerDFS = function (root) {
        if (!root) return        root.right && outerDFS(root.right)
        total += Math.abs(innerDFS(root.left) - innerDFS(root.right))
        root.left && outerDFS(root.left)
    }
    outerDFS(root)
    return total
};
```

But!!!!!!!!

看了一眼答案我觉得自己还是拿衣服了

原来计算左右节点之和，与累积左右节点只差并不矛盾，一个递归就能解决问题。就是DFS的时候顺便两者一起做了，累计左右节点就是 `return root.val + left + right` 而计算差值是 `total += Math.abs(left-right)`

```javascript
var findTilt = function(root) {
    var total = 0    var DFS = function (root) {
        if (!root) return 0        var left = 0 ,right = 0        if (root.left) {
            left = DFS(root.left)
        }
        if (root.right) {
            right = DFS(root.right)
        }
        total += Math.abs(left-right)
        return root.val + left + right
    }
    DFS(root)
    return total
};
```

还是年轻了，明明做过类似的递归
<!-- ORIGINAL CHINESE CONTENT ENDS -->
