---
draft: true
original: 'content/zh/post/145-二叉树的后序遍历.md'
title: 145-二叉树的后序遍历
description: 
categories:
  - leetcode
date: 2021-02-26 00:00:00
summary: 
---

````markdown
---
title: "145 - Binary Tree Postorder Traversal"
description: ""
categories:
  - leetcode
date: 2021-02-26 00:00:00
summary: ""
draft: true
original: 'content/zh/post/145-二叉树的后序遍历.md'
---

# 145. Binary Tree Postorder Traversal

**Published:** 2021-02-26

### 145. Binary Tree Postorder Traversal

Estimated time: 1h

Postorder traversal visits nodes in the order: Left → Right → Root

### Recursion

The recursive solution is straightforward:

```javascript
var postorderTraversal = function(root) {
    var res = [];
    if (!root) return res;
    var travel = function (node) {
        if (node.left) travel(node.left);
        if (node.right) travel(node.right);
        res.push(node.val);
    };
    travel(root);
    return res;
};
```

### Iterative

One iterative approach uses a stack and keeps track of the last node that was visited. Steps:

1. Push the root onto the stack.
2. Inspect the node on top of the stack: if it has no children, or its children have already been processed (the last visited node), then pop it and add its value to the result.
3. Otherwise, push its right child (if any) then its left child (if any) onto the stack.
4. Repeat until the stack is empty.

```javascript
var postorderTraversal = function(root) {
    var res = [];
    if (!root) return res;
    var stack = [root];
    var prev = null;
    while (stack.length) {
        var node = stack[stack.length - 1];
        // If node is a leaf or its children were already processed
        if ((!node.left && !node.right) || node.left === prev || node.right === prev) {
            node = stack.pop();
            prev = node;
            res.push(node.val);
        } else {
            if (node.right) stack.push(node.right);
            if (node.left) stack.push(node.left);
        }
    }
    return res;
};
```

### Summary

Although I've implemented preorder, inorder and postorder traversals, I'm worried I'll forget them soon — especially inorder and postorder. I haven't yet found a clear connection between them, so I'll write a short summary later to consolidate the ideas.

````
