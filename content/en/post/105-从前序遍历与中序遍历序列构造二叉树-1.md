---
title: "105 - Construct Binary Tree from Preorder and Inorder Traversal"
description: ""
categories:
  - leetcode
date: 2021-01-27 00:00:00
summary: ""
draft: false
original: 'content/zh/post/105-从前序遍历与中序遍历序列构造二叉树-1.md'
---

# 105. Construct Binary Tree from Preorder and Inorder Traversal

**Published:** 2021-01-27

Time spent: 40 min

### Recursive approach

Preorder visits nodes in the order: Root → Left → Right
Inorder visits nodes in the order: Left → Root → Right

Therefore, you can take the first element of the preorder array as the root value, then locate that value in the inorder array to determine the sizes of the left and right subtrees.

```javascript
var buildTree = function(preorder, inorder) {
    if (preorder.length === 0 || inorder.length === 0) return null;
    let nodeVal = preorder.shift();
    let node = new TreeNode(nodeVal);
    let index = inorder.indexOf(nodeVal);
    node.left = buildTree(preorder.slice(0, index), inorder.slice(0, index));
    node.right = buildTree(preorder.slice(index), inorder.slice(index + 1));
    return node;
};
```

### Optimization

Using `slice` copies arrays and can be costly. You can avoid that by passing indices (pointers) into the helper function instead of slicing arrays.

```javascript
var buildTree = function(preorder, inorder) {
    var helper = function(p_start, p_end, i_start, i_end) {
        if (p_start > p_end || i_start > i_end) return null;
        let nodeVal = preorder[p_start];
        let node = new TreeNode(nodeVal);
        let index = inorder.indexOf(nodeVal);
        let left = index - i_start;
        node.left = helper(p_start + 1, p_start + left, i_start, index - 1);
        node.right = helper(p_start + left + 1, p_end, index + 1, i_end);
        return node;
    };
    return helper(0, preorder.length - 1, 0, preorder.length - 1);
};
```

Summary:

Use the properties of preorder and inorder traversals to locate the root and determine the number of nodes in the left and right subtrees, then recursively build each subtree.
