---
draft: false
original: content/zh/post/105-从前序遍历与中序遍历序列构造二叉树-1.md
title: 105-Constructing a binary tree from pre-order and in-order traversal sequences-1
description: null
categories:
- leetcode
date: 2021-01-27 00:00:00
summary: null
---

Time: 40 minutes

####105. Construct a binary tree from pre-order and in-order traversal sequences

recursion

Pre-order traversal: center-left-right

In-order traversal: left-middle-right

Therefore, we can first find the root element from the pre-order traversal, and then determine the number of left and right subtrees from the in-order traversal.

```

javascript
var buildTree = function(preorder, inorder) {
    if (preorder.length === 0 || inorder.length=== 0) return null    let nodeVal = preorder.shift()
    let node = new TreeNode(nodeVal)
    let index = inorder.indexOf(nodeVal)
    node.left = buildTree(preorder.slice(0,index), inorder.slice(0,index))
    node.right = buildTree(preorder.slice(index),inorder.slice(index + 1))
    return node
};
```

Optimization

Slices are very performance-intensive. In fact, there is no need to pass arrays. Functions can just pass pointers.

```

javascript
var buildTree = function(preorder, inorder) {
    var helper = function (p_start,p_end,i_start,i_end) {
        if (p_start > p_end || i_start > i_end ) return null        let nodeVal = preorder[p_start]
        let node = new TreeNode(nodeVal)
        let index = inorder.indexOf(nodeVal)
        let left = index - i_start
        node.left = helper(p_start + 1 , p_start + left , i_start ,index - 1)
        node.right = helper(p_start + left + 1,p_end, index + 1,i_end)
        return node
    }
    return helper(0,preorder.length - 1,0,preorder.length - 1)
};
```

Summarize:

Using the properties of pre-order and in-order, locate the root node and find the number of left and right subtrees. Then recursively construct the left and right subtrees.

<!-- ORIGINAL CHINESE BODY STARTS -->
Time: 40 minutes

####105. Construct a binary tree from pre-order and in-order traversal sequences

recursion

Pre-order traversal: center-left-right

In-order traversal: left-middle-right

Therefore, we can first find the root element from the pre-order traversal, and then determine the number of left and right subtrees from the in-order traversal.

```

javascript
var buildTree = function(preorder, inorder) {
    if (preorder.length === 0 || inorder.length=== 0) return null    let nodeVal = preorder.shift()
    let node = new TreeNode(nodeVal)
    let index = inorder.indexOf(nodeVal)
    node.left = buildTree(preorder.slice(0,index), inorder.slice(0,index))
    node.right = buildTree(preorder.slice(index),inorder.slice(index + 1))
    return node
};
```

Optimization

Slices are very performance-intensive. In fact, there is no need to pass arrays. Functions can just pass pointers.

```

javascript
var buildTree = function(preorder, inorder) {
    var helper = function (p_start,p_end,i_start,i_end) {
        if (p_start > p_end || i_start > i_end ) return null        let nodeVal = preorder[p_start]
        let node = new TreeNode(nodeVal)
        let index = inorder.indexOf(nodeVal)
        let left = index - i_start
        node.left = helper(p_start + 1 , p_start + left , i_start ,index - 1)
        node.right = helper(p_start + left + 1,p_end, index + 1,i_end)
        return node
    }
    return helper(0,preorder.length - 1,0,preorder.length - 1)
};
```

Summarize:

Using the pre-order and in-order properties, locate the root node and calculate the number of left and right subtrees. Then, recursively construct the left and right subtrees.
<!-- ORIGINAL CHINESE BODY ENDS -->
