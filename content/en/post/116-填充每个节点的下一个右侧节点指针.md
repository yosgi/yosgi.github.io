---
draft: false
original: content/zh/post/116-填充每个节点的下一个右侧节点指针.md
title: 116-Fill in the next right node pointer of each node
description: null
categories:
- leetcode
date: 2021-03-10 00:00:00
summary: null
---

Time: 25 minutes

The main idea is to use the stack. The difference from the ordinary level-order traversal is that the stack is cleared every time

```

javascript
var connect = function(root) {
    if (!root) return null    var stack = [root]
    while(stack.length) {
        var _stack = [...stack,null]
        stack = []
        var pre = _stack.shift()
        while(_stack.length || pre) {
            pre.left && stack.push(pre.left)
            pre.right && stack.push(pre.right)
            pre.next = _stack.shift()
            pre = pre.next        }
    }
    return root};
```

Obviously, the memory space of On I used does not meet the constant space requirement of the question, considering that the links of each layer can be found in the form of a linked list by relying on the parent node.

```

javascript
while(pre) {
        var cur = pre
        while(cur) {
             cur.left.next = cur.right             cur.right.next = cur.next.left             cur = cur.next        }
    }
```

The remaining things to consider are

1. Pre needs to be saved as the leftmost node to facilitate subsequent linked list connections.
1. Next is empty on the first level.
1. The last level has no left or right nodes.

<!-- ORIGINAL CHINESE BODY STARTS -->
Time: 25 minutes

The main idea is to use the stack. The difference from the ordinary level-order traversal is that the stack is cleared every time

```

javascript
var connect = function(root) {
    if (!root) return null    var stack = [root]
    while(stack.length) {
        var _stack = [...stack,null]
        stack = []
        var pre = _stack.shift()
        while(_stack.length || pre) {
            pre.left && stack.push(pre.left)
            pre.right && stack.push(pre.right)
            pre.next = _stack.shift()
            pre = pre.next        }
    }
    return root};
```

Obviously, the memory space of On I used does not meet the constant space requirement of the question, considering that the links of each layer can be found in the form of a linked list by relying on the parent node.

```

javascript
while(pre) {
        var cur = pre
        while(cur) {
             cur.left.next = cur.right             cur.right.next = cur.next.left             cur = cur.next        }
    }
```

The remaining things to consider are

1. pre needs to be saved as the leftmost node to facilitate subsequent linking in a linked list.
1. The next field on the first level is empty.
1. The last level has no left or right nodes.
<!-- ORIGINAL CHINESE BODY ENDS -->
