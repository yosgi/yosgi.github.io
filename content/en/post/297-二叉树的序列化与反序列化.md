---
draft: true
original: 'content/zh/post/297-二叉树的序列化与反序列化.md'
title: 297-二叉树的序列化与反序列化
description: 
categories:
  - leetcode
date: 2021-03-04 00:00:00
summary: 
---

# ENGLISH TRANSLATION NEEDED

This is an automatically generated English stub. Please translate the content below into English and remove the `draft: true` flag when ready.

<!-- ORIGINAL CHINESE CONTENT STARTS -->
# 297. 二叉树的序列化与反序列化

**发布日期：** 2021年03月04日

用时：30min

序列化很简单，使用BFS可以解决

反序列化需要用到二叉树的性质，即第 i 个节点的子节点分别为 (i + 1) * 2 - 1 和 ( i + 1) * 2, 流程

1. 找到父节点，入栈，此时指针 i 在 父节点的 val 上
1. 父节点出栈，找到父节点的左右节点，指针根据规则找到 两遍的值，左右节点入栈， i++
1. 重复 1
```javascript
var serialize = function(root) {
    if (!root) return []
    var que = [root]
    var res = []
    while(que.length) {
        var cur = que.shift()
        if (cur) {
            res.push(cur.val);
            que.push(cur.left);            que.push(cur.right);
        } else {
            res.push('null');
        }
    }
    return res.join(',')
};/** * Decodes your encoded data to tree. * * @param {string} data * @return {TreeNode} */var deserialize = function(data) {
    if (!data.length) return null    var nodes = data.split(',')
    var i = 0
    var root = new TreeNode(nodes[i])
    var que = [root]
    while ( que.length) {
        var node  = que.shift()
        var left = nodes[ (i + 1) * 2 - 1]
        var right = nodes[ (i + 1) * 2]
        if (left !== 'null') {
            node.left = new TreeNode(left)
            que.push(node.left)
        } else {
            node.left = null        }
        if (right !== 'null') {
            node.right = new TreeNode(right)
            que.push(node.right)
        } else {
            node.right = null        }
        i++    }
    return root};
```
<!-- ORIGINAL CHINESE CONTENT ENDS -->
